#!/bin/bash

#
# Run this script on the headnode to set up a local zone for developing Cloud
# Analytics.  The script takes a single argument: the desired username.
#

shopt -s xpg_echo

sh_arg0=$(basename $0)
sh_tmpbase=/var/tmp/$sh_arg0.$$
sh_urlbase="http://10.99.99.8:8080"
sh_capi="http://10.99.99.11:8080"
sh_user="$1"
sh_curlcmd="curl -u admin:tot@ls3crit"
sh_skip_setup=false
sh_dataset_name=smartos
sh_head_hostname=headnode

sh_dataset_version=
sh_cust=
sh_custuri=
sh_conturi=
sh_zonename=
sh_zoneip=

function fail
{
	local msg="$*"
	[[ -z "$msg" ]] && msg="failed"
	echo "$sh_arg0: $msg" >&2
	exit 1
}

function sh_curl
{
	$sh_curlcmd -H 'Accept: application/json' -s --url $1
}

function sh_extract
{
	json | grep \"$1\" | cut -d\" -f4
}

function sh_extract_header
{
	egrep "^$1: " | sed -e "s#$1: ##" | tr -d '\r\n'
}

function sh_loadcust
{
	sh_cust=$(sh_curl $sh_capi/customers | json 0.uuid)
	sh_custuri=/customers/$sh_cust
}

function sh_load_dataset
{
	sh_dataset_version=$($sh_curlcmd -s \
	    --url $sh_urlbase/search/datasets?name=$sh_dataset_name | \
	    json 0.version)
}

function sh_enable_provision
{
	local servers length ii entry
	servers=$($sh_curlcmd -s --url $sh_urlbase/servers)
	[[ $? -eq 0 ]] || fail "failed to list servers"
	length=$(echo $servers | json length)
	entry=""
	for (( ii=0; ii < length; ii++)) {
		if echo $servers | json $ii.hostname | \
		    egrep -s "^$sh_head_hostname$";
		then
			entry=$(echo $servers | json $ii.uri)
		fi	
	}
	[[ -z $entry ]] && fail "couldn't find $sh_head_hostname entry"
	$sh_curlcmd -s -X PUT -F "api_provisionable=true" \
	    --url $sh_urlbase/admin$entry >/dev/null
	[[ $? -eq 0 ]] || fail "failed to make $sh_head_hostname provisionable"
}

function sh_provision
{
        local cust=$1 dataset=$2
	local out turi

        out=$($sh_curlcmd -s -i -X POST -d dataset=$dataset \
	    -d package="regular_256" -d networks="admin" \
	    -d customer_uuid=$cust \
	    --url "$sh_urlbase/zones" 2>&1)

        [[ $? -eq 0 ]] || fail "failed to create zone: $out"
	turi=$(echo "$out" | sh_extract_header X-Joyent-Transition-URI)
	[[ -n $turi ]] || fail "no transition URI: $out"

	while [[ -z $sh_conturi ]]; do
		sleep 1
		out=$($sh_curlcmd -s -i --url $sh_urlbase$turi 2>&1)
        	[[ $? -eq 0 ]] || fail "failed to get transition: $out"
		sh_conturi=$(echo "$out" | sh_extract_header Location)
		echo ".\c"
	done

	out=$(sh_curl $sh_urlbase$sh_conturi)
	sh_zonename=$(echo "$out" | json name)
	[[ -n $sh_zonename ]] || fail "no zone name: $out"
	sh_zoneip=$(echo "$out" | json ips.0.address)
	[[ -n $sh_zoneip ]] || fail "no zone ip: $out"
}

function sh_upload_keys
{
	local nkeys

	echo "Checking for existing authorized keys ... \c"
	nkeys=$($sh_curlcmd -H "Accept: application/json" -s \
	    --url $sh_capi$sh_custuri/keys | json length) || \
	    fail "failed to list existing keys"
	[[ $nkeys -gt 0 ]] && echo "keys present already" && return
	echo "none."

	local knum=0
	while read key; do
		knum=$(( knum + 1 ))
		echo "Uploading key $knum ... \c"
		$sh_curlcmd -f -s -i --url $sh_capi$sh_custuri/keys \
		    -F "name=key$knum" -F "key=$key" > /dev/null || \
		    fail "failed"
		echo "done."
	done < $HOME/.ssh/authorized_keys
}

[[ -n $sh_user ]] || fail "usage: $sh_arg0 <username>"

echo "Retrieving customer uri ... \c"
sh_loadcust || fail "failed"
[[ -n $sh_custuri ]] || fail "no customer uri found"
echo "$sh_custuri"

sh_upload_keys || fail "failed"

echo "Finding version of dataset "$sh_dataset_name" ... \c"
sh_load_dataset || fail "failed"
[[ -n $sh_dataset_version ]] || fail "no version found"
echo "$sh_dataset_version"

echo "Marking headnode provisionable ... \c"
sh_enable_provision || fail "failed"
echo "done."

echo "Provisioning $sh_dataset_name-$sh_dataset_version zone ... \c"
sh_provision $sh_cust "$sh_dataset_name-$sh_dataset_version" || fail "failed"
echo "$sh_zonename ($sh_zoneip)"

#
# Work around PROV-487.  The zone may be booted, but it might be running zoneinit,
# after which it will reboot.  We need to wait for this second boot before
# trying to log in.  We separately wait for the reboot to complete and then for
# logins to work again.  We check for network connectivity to make sure that
# when we run our real setup script later it can assume a working network
# environment.
#
echo "Waiting for zone $sh_zonename to reboot ... \c"
while zlogin $sh_zonename pgrep -x reboot > /dev/null 2>&1; do
	echo ".\c"
	sleep 1
done
echo " done."

echo "Waiting for zone $sh_zonename to boot (+ net) ... \c"
while ! zlogin $sh_zonename ping 8.8.8.8 > /dev/null 2>&1; do
	echo ".\c"
	sleep 1
done
echo " done."

cat > /zones/ca/root/root/setup_zone.sh <<EOF
#!/bin/bash
shopt -s xpg_echo

function fail
{
	echo "$*"
	exit 1
}

echo "Enabling root login via ssh for CA zone ... \c"
sed -e 's#^PermitRootLogin no\$#PermitRootLogin yes#' /etc/ssh/sshd_config > \
    /etc/ssh/sshd_config_new && mv /etc/ssh/sshd_config_new /etc/ssh/sshd_config \
    || fail "failed"
svcadm disable -s ssh || fail "failed to disable service"
svcadm enable -s ssh || fail "failed to enable service"
echo "done."
EOF

chmod +x /zones/ca/root/root/setup_zone.sh
zlogin ca /root/setup_zone.sh || fail

cat > /zones/${sh_zonename}/root/root/setup_zone.sh <<EOF
#!/bin/bash
shopt -s xpg_echo

function fail
{
	echo "\$*"
	exit 1
}

echo "Setting nodename to 'devel' ... \c"
hostname devel || fail "failed to set hostname"
echo devel > /etc/nodename || fail "failed to write to /etc/nodename"
echo "done."

echo "Updating DNS ... \c"
cat > /etc/resolv.conf << DNS
domain joyent.us
nameserver 8.8.8.8
nameserver 8.8.4.4
DNS
echo "done."

echo "Testing DNS ... \c"
ping example.com || fail "failed"

echo "Enabling root login via ssh ... \c"
sed -e 's#^PermitRootLogin no\$#PermitRootLogin yes#' /etc/ssh/sshd_config > \
    /etc/ssh/sshd_config_new && mv /etc/ssh/sshd_config_new /etc/ssh/sshd_config \
    || fail "failed"
svcadm disable -s ssh || fail "failed to disable service"
svcadm enable -s ssh || fail "failed to enable service"
echo "done."

echo "Creating user '$sh_user' ... \c"
if egrep ^$sh_user: /etc/passwd > /dev/null; then
	echo "skipped (already exists)"
else
mkdir -p /home/$sh_user/.ssh || fail "failed to create /home/$sh_user"
useradd -c $sh_user -d /home/$sh_user -G staff -s /bin/bash \
    -K defaultpriv=basic,dtrace_user,dtrace_proc,dtrace_kernel $sh_user || \
    fail "failed to create user"
passwd -N $sh_user || fail "passwd -N failed for $sh_user"
cat > /home/$sh_user/.npmrc << NPMRC
root = ~/.node_modules
tar = gtar
NPMRC

cat > /home/$sh_user/.profile << PROFILE
export PATH=/usr/bin:/usr/sbin:/opt/local/bin:/opt/local/sbin:/usr/sfw/bin:/usr/openwin/bin:/usr/ccs/bin:/usr/xpg4/bin:/opt/local/gcc34/bin
export MANPATH=/opt/local/man:/opt/local/share/man:/usr/share/man:/usr/sfw/share/man:/usr/openwin/share/man
PROFILE
chown -R $sh_user:staff /home/$sh_user || fail "failed to chmod"

echo "done."
fi

# Update PATH to include GNU egrep by default, and for pkgin
export PATH=/opt/local/bin:$PATH

echo "Setting up pkgsrc and packages ... \c"
pkgin update > /var/tmp/pkgin_update.out
pkgin -y in gcc34 gcc-tools cscope pkg-config gmake scmgit python24 python26 png npm GeoIP GeoLiteCity ghostscript > /var/tmp/pkgin_install.out || fail "failed"
echo "done."
EOF

chmod +x /zones/$sh_zonename/root/root/setup_zone.sh
[[ $sh_skip_setup = true ]] || zlogin $sh_zonename /root/setup_zone.sh || fail

echo "Setup complete for zone $sh_zonename at $sh_zoneip."
echo "If you have not yet done so, you will need to set up a public key for the "
echo "admin user in CAPI in order to log into the zone as either root or $sh_user."
