#!/bin/bash

#
# Run this script on the headnode to set up a local zone for developing Cloud
# Analytics.  The script takes a single argument: the desired username.
#

shopt -s xpg_echo

sh_arg0=$(basename $0)
sh_tmpbase=/var/tmp/$sh_arg0.$$
sh_user="$1"

function fail
{
	local msg="$*"
	[[ -z "$msg" ]] && msg="failed"
	echo "$sh_arg0: $msg" >&2
	exit 1
}

[[ -n $sh_user ]] || fail "usage: $sh_arg0 <username>"

echo "Marking headnode provisionable ... \c"
sdc-compnode -c headnode -r false || fail "failed"
echo "done."

echo "Provisioning cloud services ... \c"
sdc-setup -c headnode -A || fail "failed"
echo "done."

[[ -f /lib/sdc/config.sh ]] || fail "Missing /lib/sdc/config.sh"

. /lib/sdc/config.sh
load_sdc_config

sh_urlbase="${CONFIG_mapi_client_url}"
sh_capi="${CONFIG_capi_client_url}"
sh_mapicurlcmd="curl -u ${CONFIG_mapi_http_admin_user}"
sh_mapicurlcmd="$sh_mapicurlcmd:${CONFIG_mapi_http_admin_pw}"
sh_capicurlcmd="curl -u ${CONFIG_capi_http_admin_user}"
sh_capicurlcmd="$sh_capicurlcmd:${CONFIG_capi_http_admin_pw}"
sh_skip_setup=false
sh_dataset_name=smartos
sh_head_hostname=$(hostname)

sh_cazone=
sh_dataset_version=
sh_cust=
sh_custuri=
sh_conturi=
sh_zonename=
sh_zoneip=

function sh_capicurl
{
	$sh_capicurlcmd -H 'Accept: application/json' -s --url $1
}

function sh_mapicurl
{
	$sh_mapicurlcmd -H 'Accept: application/json' -s --url $1
}

function sh_extract
{
	json | grep \"$1\" | cut -d\" -f4
}

function sh_extract_header
{
	egrep "^$1: " | sed -e "s#$1: ##" | tr -d '\r\n'
}

function sh_loadcust
{
	sh_cust=$(sh_capicurl $sh_capi/customers | json 0.uuid)
	sh_custuri=/customers/$sh_cust
}

function sh_loadcazone
{
	sh_cazone=$(sdc-setup -l | grep '\<ca\>' | awk '{print $1}')
	[[ -n $sh_cazone ]] || \
	    fail "ca zone not found.  have you run sdc-setup -A?"
}

function sh_load_dataset
{
	echo "(using hardcoded) \c"
	sh_dataset_version=1.3.18	
}

function sh_provision
{
        local cust=$1 dataset=$2
	local out turi

        out=$($sh_mapicurlcmd -s -i -X POST -d dataset=$dataset \
	    -d package="regular_256" -d networks="admin" \
	    -d customer_uuid=$cust \
	    --url "$sh_urlbase/zones" 2>&1)

        [[ $? -eq 0 ]] || fail "failed to create zone: $out"
	turi=$(echo "$out" | sh_extract_header X-Joyent-Transition-URI)
	[[ -n $turi ]] || fail "no transition URI: $out"

	while [[ -z $sh_conturi ]]; do
		sleep 1
		out=$($sh_mapicurlcmd -s -i --url $sh_urlbase$turi 2>&1)
        	[[ $? -eq 0 ]] || fail "failed to get transition: $out"
		sh_conturi=$(echo "$out" | sh_extract_header Location)
		echo ".\c"
	done

	out=$(sh_mapicurl $sh_urlbase$sh_conturi)
	sh_zonename=$(echo "$out" | json name)
	[[ -n $sh_zonename ]] || fail "no zone name: $out"
	sh_zoneip=$(echo "$out" | json ips.0.address)
	[[ -n $sh_zoneip ]] || fail "no zone ip: $out"
}

function sh_upload_keys
{
	local nkeys

	echo "Checking for existing authorized keys ... \c"
	nkeys=$($sh_capicurlcmd -H "Accept: application/json" -s \
	    --url $sh_capi$sh_custuri/keys | json length) || \
	    fail "failed to list existing keys"
	[[ $nkeys -gt 0 ]] && echo "keys present already" && return
	echo "none."

	local knum=0
	while read key; do
		knum=$(( knum + 1 ))
		echo "Uploading key $knum ... \c"
		$sh_capicurlcmd -f -s -i --url $sh_capi$sh_custuri/keys \
		    -F "name=key$knum" -F "key=$key" > /dev/null || \
		    fail "failed"
		echo "done."
	done < $HOME/.ssh/authorized_keys
}

echo "Retrieving customer uri ... \c"
sh_loadcust || fail "failed"
[[ -n $sh_custuri ]] || fail "no customer uri found"
echo "$sh_custuri"

sh_upload_keys || fail "failed"

echo "Finding CA zone ... \c"
sh_loadcazone || fail "failed"
echo "$sh_cazone."

echo "Finding version of dataset "$sh_dataset_name" ... \c"
sh_load_dataset || fail "failed"
[[ -n $sh_dataset_version ]] || fail "no version found"
echo "$sh_dataset_version"

echo "Provisioning $sh_dataset_name-$sh_dataset_version zone ... \c"
sh_provision $sh_cust "$sh_dataset_name-$sh_dataset_version" || fail "failed"
echo "$sh_zonename ($sh_zoneip)"

#
# Work around PROV-487.  The zone may be booted, but it might be running zoneinit,
# after which it will reboot.  We need to wait for this second boot before
# trying to log in.  We separately wait for the reboot to complete and then for
# logins to work again.  We check for network connectivity to make sure that
# when we run our real setup script later it can assume a working network
# environment.
#
echo "Waiting for zone $sh_zonename to reboot ... \c"
while zlogin $sh_zonename pgrep -x reboot > /dev/null 2>&1; do
	echo ".\c"
	sleep 1
done
echo " done."

echo "Waiting for zone $sh_zonename to boot (+ net) ... \c"
while ! zlogin $sh_zonename ping 8.8.8.8 > /dev/null 2>&1; do
	echo ".\c"
	sleep 1
done
echo " done."

cp /root/.ssh/authorized_keys /zones/$sh_zonename/root/var/tmp || fail \
    "failed to cp ssh key"
cat > /zones/$sh_cazone/root/root/setup_zone.sh <<EOF
#!/bin/bash
shopt -s xpg_echo

function fail
{
	echo "$*"
	exit 1
}

echo "Enabling root login via ssh for CA zone ... \c"
sed -e 's#^PermitRootLogin no\$#PermitRootLogin yes#' /etc/ssh/sshd_config > \
    /etc/ssh/sshd_config_new && mv /etc/ssh/sshd_config_new /etc/ssh/sshd_config \
    || fail "failed"
svcadm disable -s ssh || fail "failed to disable service"
svcadm enable -s ssh || fail "failed to enable service"
echo "done."
EOF

chmod +x /zones/$sh_cazone/root/root/setup_zone.sh
zlogin $sh_cazone /root/setup_zone.sh || fail

cat > /zones/${sh_zonename}/root/root/setup_zone.sh <<EOF
#!/bin/bash
shopt -s xpg_echo

function fail
{
	echo "\$*"
	exit 1
}

echo "Setting nodename to 'devel' ... \c"
hostname devel || fail "failed to set hostname"
echo devel > /etc/nodename || fail "failed to write to /etc/nodename"
echo "done."

echo "Updating DNS ... \c"
cat > /etc/resolv.conf << DNS
domain joyent.us
nameserver 8.8.8.8
nameserver 8.8.4.4
DNS
echo "done."

echo "Testing DNS ... \c"
ping example.com || fail "failed"

echo "Enabling root login via ssh ... \c"
sed -e 's#^PermitRootLogin no\$#PermitRootLogin yes#' /etc/ssh/sshd_config > \
    /etc/ssh/sshd_config_new && mv /etc/ssh/sshd_config_new /etc/ssh/sshd_config \
    || fail "failed"
svcadm disable -s ssh || fail "failed to disable service"
svcadm enable -s ssh || fail "failed to enable service"
echo "done."

echo "Creating user '$sh_user' ... \c"
if egrep ^$sh_user: /etc/passwd > /dev/null; then
	echo "skipped (already exists)"
else
mkdir -p /home/$sh_user/.ssh || fail "failed to create /home/$sh_user"
useradd -c $sh_user -d /home/$sh_user -G staff -s /bin/bash \
    -K defaultpriv=basic,dtrace_user,dtrace_proc,dtrace_kernel $sh_user || \
    fail "failed to create user"
passwd -N $sh_user || fail "passwd -N failed for $sh_user"
cat > /home/$sh_user/.npmrc << NPMRC
root = ~/.node_modules
tar = gtar
NPMRC

cat > /home/$sh_user/.profile << PROFILE
export PATH=/usr/bin:/usr/sbin:/opt/local/bin:/opt/local/sbin:/usr/sfw/bin:/usr/openwin/bin:/usr/ccs/bin:/usr/xpg4/bin
export MANPATH=/opt/local/man:/opt/local/share/man:/usr/share/man:/usr/sfw/share/man:/usr/openwin/share/man
PROFILE
chown -R $sh_user:staff /home/$sh_user || fail "failed to chmod"

echo "done."

echo "Setting up user ssh keys... \c "
cp /var/tmp/authorized_keys /home/$sh_user/.ssh/authorized_keys || fail \
    "failed to set up ssh keys"
chmod 600 /home/$sh_user/.ssh/authorized_keys || fail "failed to chmod"
chown $sh_user /home/$sh_user/.ssh/authorized_keys || fail "failed to chown"
rm -f /var/tmp/authorized_keys
echo "done."
fi

# Update PATH to include GNU egrep by default, and for pkgin
export PATH=/opt/local/bin:$PATH

echo "Setting up pkgsrc and packages ... \c"
pkgin -f update > /var/tmp/pkgin_update.out
pkgin -y in gcc-compiler gcc-runtime gcc-tools cscope pkg-config gmake scmgit python24 python26 png npm-1.0.94 GeoIP GeoLiteCity ghostscript > /var/tmp/pkgin_install.out || fail "failed"
echo "done."
EOF

chmod +x /zones/$sh_zonename/root/root/setup_zone.sh
[[ $sh_skip_setup = true ]] || zlogin $sh_zonename /root/setup_zone.sh || fail

echo "Setup complete for zone $sh_zonename at $sh_zoneip."
echo "If you have not yet done so, you will need to set up a public key for the "
echo "admin user in CAPI in order to log into the zone as either root or $sh_user."
