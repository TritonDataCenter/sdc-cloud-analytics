#!/usr/bin/bash

#
# catest: a tool and framework for testing cloud analytics.
#

#
# Test name format:
# Tests can be in any language and should be of the format
# tst.<testname>.<language ext>. Language extension tells us which interpreter
# we will end up firing up to test this, i.e. shell, node, etc. Tests can be in
# an arbitrary directory hierarchy 
#

#
# Per test actions:
# - Make a directory for that test
# - cd into that directory and exec the test
# - Redirect standard output and standard error to files
# - Tests return 0 to indicate success, non-zero to indicate failure
#

shopt -s xpg_echo

#
# Canoncial name
#
PNAME=$(basename $0)

#
# Should we keep the output of successful tests?
#
OPT_KEEP_SUCCESS=0

#
# Should we run all tests
#
OPT_RUN_ALL=0

#
# Output directory
#
OPT_OUTPUT_DIR=""

#
# Name for our results directory
#
OUTPUT_DIR_NAME="catest.$$"

#
# Name of the top level directory containts tests
#
TST_DIR_NAME="tst"

#
# Tests that ran, but failed
#
CURRENT_FAILURES=0

#
# Tests that passed
#
CURRENT_PASSES=0

#
# Total number of tests run
#
TESTS_RUN=0

#
# Number of tests skipped
#
TESTS_SKIPPED=0

#
# node relative path
#
NODE_REL="deps/node/node"

#
# Absolute path to the node executable
# This is exported to the environment
#
NODE_EXEC=""

#
# Absolute path to the bash executable
#
BASH_EXEC="/usr/bin/bash"

#
# Populated via input arguments, is an absolute path
#
OUTPUT_BASE_DIR=""

#
# Temporary directory for tests to use
#
CATMPDIR="/var/tmp/catest.$$_tmpfiles"
export CATMPDIR

#
# Populated via setup-output, is an absolute path
#
OUTPUT_DIR=""

#
# Populated via get-tests, is a series of absolute paths
#
TESTS=""

#
# Make sure that we use a different AMQP Namespace
#
CA_AMQP_PREFIX="test"
export CA_AMQP_PREFIX

#
# Keep track of the hostname and export that env variable for these tests as a
# fallback for those who don't set it themselves.
#
HOSTNAME=$(/usr/bin/hostname)
export HOST=$HOSTNAME

function fail
{
	echo "$@" >&2
	exit 1
}

function usage
{
	if [[ $# -ne 0 ]]; then
		echo "$PNAME: $@"
	fi
	cat <<USAGE >&2
Usage: $PNAME -o dir [opts] tests

Runs specified tests for cloud analytics.

	-o directory	Specifies the output directory for tests
	-a 		Runs all tests, ignores tests passed in
	-h		Output this message
	-k		Keep output from all tests, not just failures

USAGE
	exit 2
}


function setup
{
	base=$1
	pushd "$base/../" >/dev/null
	export SRC=$(pwd)
	if [[ ! -f $NODE_REL || ! -x $NODE_REL ]]; then
		fail "Node executable not at deps/node/node"
	fi
	NODE_EXEC="$(pwd)/$NODE_REL"
	export NODE_EXEC=$NODE_EXEC
	popd >/dev/null
	pushd $base >/dev/null
	export $(./npath)
	popd >/dev/null
	if [[ ! -f $BASH_EXEC || ! -x $BASH_EXEC ]]; then
		fail "Missing bash executable at $BASH"
	fi
}

function get-output-base
{
	pushd $1 >/dev/null
	OUTPUT_BASE_DIR=$(pwd)
	popd >/dev/null
}

#
# Finds all of the tests that we are going to run
#
function get-all-tests
{
	base=$1
	tst_root="$base/../$TST_DIR_NAME"
	[[ -d $tst_root ]] || fail "Cannot find test directory"
	pushd $tst_root >/dev/null
	tst_root=$(pwd)
	popd >/dev/null
	TESTS=$(find $tst_root -name 'tst*.js' -o -name 'tst*.sh')
	[[ "TESTS" != "" ]] || fail "Found no tests to run"
}

function welcome
{
	NUM_TESTS=$(echo $TESTS | wc -w)
	printf "Welcome to catest\n"
	printf "Configuration:\n"
	printf "\tOutput Directory: $OUTPUT_BASE_DIR/$OUTPUT_DIR_NAME\n"
	printf "\tTemp Directory: $CATMPDIR\n"
	printf "\tNode executable: $NODE_EXEC\n"
	printf "\tKeep non-failure output: $OPT_KEEP_SUCCESS\n"
	printf "\tFound %d test(s) to run\n" $NUM_TESTS
	printf "\n"
	printf "\n===================================================\n\n"
}

#
# Make our output directory
#
function setup-output
{
	pushd $OUTPUT_BASE_DIR >/dev/null
	mkdir $OUTPUT_DIR_NAME || fail "Can't make output directory"
	cd $OUTPUT_DIR_NAME
	OUTPUT_DIR=$(pwd)
	popd >/dev/null

	mkdir -p $CATMPDIR || fail "Can'tmake temp directory"
}

#
# Executes a single test
#
function execute-test
{
	[[ $# -eq 1 ]] || fail "Missing test to execute"
	test_path=$1
	test_name=$(basename $1)
	test_label=$(echo $test_path | sed -e s#^$SRC/##)
	test_dir=$(dirname $1)
	test_odir="$OUTPUT_DIR/test.$TESTS_RUN"
	ext=${test_name##*.}
	reason=
	EXEC=""

	case "$ext" in
	"sh") 	EXEC=$BASH_EXEC	;;
	"js") 	EXEC=$NODE_EXEC ;;
	*) 	echo "Skipping test $test_label (unknown type)"
		((TESTS_SKIPPED++))
		return 0
		;;
	esac

	echo "Executing test $test_label ... \c"

	mkdir "$test_odir" >/dev/null || fail "Can't make directory"
	pushd "$test_dir" >/dev/null
	$EXEC $test_name >$test_odir/$$.out 2>$test_odir/$$.err
	execres=$?
	popd > /dev/null

	if [[ $execres != 0 ]]; then
		reason="test returned $execres instead of 0"
	elif [[ -f $test_path.out ]] && \
	    ! diff $test_path.out $test_odir/$$.out > /dev/null ; then
		cp $test_path.out $test_odir/$test_name.out
		reason="stdout mismatch"
	fi

	if [[ -z $reason ]]; then
		echo "success."
		mv "$test_odir" "$OUTPUT_DIR/success.$CURRENT_PASSES"
		((CURRENT_PASSES++))
		return;
	fi

	echo "FAILED."
	echo "$test_path failed: $reason" > "$test_odir/README"
	printf ">>> failure details in %s/failure.%d\n\n" \
	    $OUTPUT_DIR $CURRENT_FAILURES
	cp "$test_path" "$test_odir/$test_name"
	mv "$test_odir" "$OUTPUT_DIR/failure.$CURRENT_FAILURES"
	((CURRENT_FAILURES++))
}

#
# Print out final numbers
#
function results
{
	printf "\n===================================================\n\n"
	printf "Results:\n"
	printf "\tTests passed:\t%2d/%2d\n" $CURRENT_PASSES $TESTS_RUN
	printf "\tTests failed:\t%2d/%2d\n" $CURRENT_FAILURES $TESTS_RUN
	printf "\tTests skipped:\t%2d/%2d\n" $TESTS_SKIPPED $TESTS_RUN
	printf "\n===================================================\n"
}

function cleanup
{
	if [ $OPT_KEEP_SUCCESS -eq 0 ]; then
		pushd $OUTPUT_DIR >/dev/null
		rm -rf success.*
		rm -rf error.*
		popd >/dev/null
	fi
}

base=$(dirname $0)

while getopts ":o:akh" c $@; do
	case "$c" in
	a) 
		OPT_RUN_ALL=1
		;;
	k)
		OPT_KEEP_SUCCESS=1
		;;
	o)
		OPT_OUTPUT_DIR=$OPTARG	
		;;
	h)
		usage
		;;
	:)
		usage "option requires an argument -- $OPTARG"
		;;
	*)
		usage "invalid option: $OPTARG"
		;;
	esac
done

shift $((OPTIND-1))

if [ "$OPT_OUTPUT_DIR" == "" ]; then
	OPT_OUTPUT_DIR="/var/tmp"
fi

if [ $# -eq 0 -a $OPT_RUN_ALL -eq 0 ]; then
	usage "must specify tests to run or -a"
fi

setup $base
get-output-base $OPT_OUTPUT_DIR

if [ $OPT_RUN_ALL -eq 1 ]; then
	get-all-tests $base
else
	for t in $@; do
		[[ -f $t ]] || fail "cannot find test $t"
		pushd $(dirname $t) >/dev/null
		abs=$(pwd)
		popd >/dev/null
		TESTS="$abs/$(basename $t) $TESTS"
	done
fi

welcome
setup-output

for t in $(echo $TESTS | sort); do
	execute-test $t
	((TESTS_RUN++))
done
results
cleanup
exit $CURRENT_FAILURES
